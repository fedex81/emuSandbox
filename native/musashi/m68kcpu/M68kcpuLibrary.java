package m68kcpu;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.TypedPointer;
import org.bridj.ann.Array;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
import org.bridj.util.DefaultParameterizedType;
/**
 * Wrapper for library <b>m68kcpu</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("m68kcpu") 
@Runtime(CRuntime.class) 
public class M68kcpuLibrary {
	static {
		BridJ.register();
	}
	public static final int M68K_CPU_TYPE_INVALID = 0;
	public static final int M68K_CPU_TYPE_68000 = 1;
	public static final int M68K_CPU_TYPE_68010 = 2;
	public static final int M68K_CPU_TYPE_68EC020 = 3;
	public static final int M68K_CPU_TYPE_68020 = 4;
	public static final int M68K_CPU_TYPE_68EC030 = 5;
	public static final int M68K_CPU_TYPE_68030 = 6;
	public static final int M68K_CPU_TYPE_68EC040 = 7;
	public static final int M68K_CPU_TYPE_68LC040 = 8;
	public static final int M68K_CPU_TYPE_68040 = 9;
	public static final int M68K_CPU_TYPE_SCC68070 = 10;
	/**
	 * enum values<br>
	 * <i>native declaration : m68k.h</i>
	 */
	public enum m68k_register_t implements IntValuedEnum<m68k_register_t > {
		M68K_REG_D0(0),
		M68K_REG_D1(1),
		M68K_REG_D2(2),
		M68K_REG_D3(3),
		M68K_REG_D4(4),
		M68K_REG_D5(5),
		M68K_REG_D6(6),
		M68K_REG_D7(7),
		M68K_REG_A0(8),
		M68K_REG_A1(9),
		M68K_REG_A2(10),
		M68K_REG_A3(11),
		M68K_REG_A4(12),
		M68K_REG_A5(13),
		M68K_REG_A6(14),
		M68K_REG_A7(15),
		M68K_REG_PC(16),
		M68K_REG_SR(17),
		M68K_REG_SP(18),
		M68K_REG_USP(19),
		M68K_REG_ISP(20),
		M68K_REG_MSP(21),
		M68K_REG_SFC(22),
		M68K_REG_DFC(23),
		M68K_REG_VBR(24),
		M68K_REG_CACR(25),
		M68K_REG_CAAR(26),
		M68K_REG_PREF_ADDR(27),
		M68K_REG_PREF_DATA(28),
		M68K_REG_PPC(29),
		M68K_REG_IR(30),
		/** Type of CPU being run */
		M68K_REG_CPU_TYPE(31);
		m68k_register_t(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<m68k_register_t > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<m68k_register_t > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/** <i>native declaration : m68kconf.h</i> */
	public static final int OPT_OFF = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int OPT_ON = (int)1;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int OPT_SPECIFY_HANDLER = (int)2;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_COMPILE_FOR_MAME = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_010 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_EC020 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_020 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_030 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_040 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_SEPARATE_READS = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_SIMULATE_PD_WRITES = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_INT_ACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_BKPT_ACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_TRACE = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_RESET = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_CMPILD_HAS_CALLBACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_RTE_HAS_CALLBACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_TAS_HAS_CALLBACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_ILLG_HAS_CALLBACK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_FC = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_MONITOR_PC = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_INSTRUCTION_HOOK = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_PREFETCH = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_ADDRESS_ERROR = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_LOG_ENABLE = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_LOG_1010_1111 = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_EMULATE_PMMU = (int)0;
	/** <i>native declaration : m68kconf.h</i> */
	public static final int M68K_USE_64_BIT = (int)1;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_NONE = (int)0;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_1 = (int)1;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_2 = (int)2;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_3 = (int)3;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_4 = (int)4;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_5 = (int)5;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_6 = (int)6;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_IRQ_7 = (int)7;
	/** <i>native declaration : m68k.h</i> */
	public static final long M68K_INT_ACK_AUTOVECTOR = (long)0xffffffffL;
	/** <i>native declaration : m68k.h</i> */
	public static final int M68K_INT_ACK_SPURIOUS = (int)0xfffffffe;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int M68K_INT_GT_32_BIT = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_RESET = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_BUS_ERROR = (int)2;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_ADDRESS_ERROR = (int)3;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_ILLEGAL_INSTRUCTION = (int)4;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_ZERO_DIVIDE = (int)5;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_CHK = (int)6;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_TRAPV = (int)7;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_PRIVILEGE_VIOLATION = (int)8;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_TRACE = (int)9;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_1010 = (int)10;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_1111 = (int)11;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_FORMAT_ERROR = (int)14;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_UNINITIALIZED_INTERRUPT = (int)15;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_SPURIOUS_INTERRUPT = (int)24;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_INTERRUPT_AUTOVECTOR = (int)24;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int EXCEPTION_TRAP_BASE = (int)32;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int FUNCTION_CODE_USER_DATA = (int)1;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int FUNCTION_CODE_USER_PROGRAM = (int)2;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int FUNCTION_CODE_SUPERVISOR_DATA = (int)5;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int FUNCTION_CODE_SUPERVISOR_PROGRAM = (int)6;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int FUNCTION_CODE_CPU_SPACE = (int)7;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_000 = (int)(0x00000001);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_008 = (int)(0x00000002);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_010 = (int)(0x00000004);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_EC020 = (int)(0x00000008);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_020 = (int)(0x00000010);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_EC030 = (int)(0x00000020);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_030 = (int)(0x00000040);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_EC040 = (int)(0x00000080);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_LC040 = (int)(0x00000100);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_040 = (int)(0x00000200);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CPU_TYPE_SCC070 = (int)(0x00000400);
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int STOP_LEVEL_STOP = (int)1;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int STOP_LEVEL_HALT = (int)2;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int INSTRUCTION_YES = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int INSTRUCTION_NO = (int)0x08;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int MODE_READ = (int)0x10;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int MODE_WRITE = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int RUN_MODE_NORMAL = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int RUN_MODE_BERR_AERR_RESET = (int)1;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final Pointer<? > NULL = (Pointer<? >)(Pointer.pointerToAddress(0, void.class));
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int m68ki_tas_callback = (int)1;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int m68ki_get_address_space = (int)1;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int NFLAG_SET = (int)0x80;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int NFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CFLAG_SET = (int)0x100;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int CFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int XFLAG_SET = (int)0x100;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int XFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int VFLAG_SET = (int)0x80;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int VFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int ZFLAG_SET = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final long ZFLAG_CLEAR = (long)0xffffffffL;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int SFLAG_SET = (int)4;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int SFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int MFLAG_SET = (int)2;
	/** <i>native declaration : m68kcpu.h</i> */
	public static final int MFLAG_CLEAR = (int)0;
	/** <i>native declaration : m68k.h</i> */
	public static abstract class M68K_BUS_WRITE extends Callback<M68K_BUS_WRITE > {
		public abstract void apply(int int1, int int2, int int3);
	};
	/** <i>native declaration : m68k.h</i> */
	public static abstract class M68K_BUS_READ extends Callback<M68K_BUS_READ > {
		public abstract int apply(int int1, int int2);
	};
	/** <i>native declaration : m68k.h:229</i> */
	public static abstract class m68k_set_int_ack_callback_callback_callback extends Callback<m68k_set_int_ack_callback_callback_callback > {
		public abstract int apply(int int_level);
	};
	/** <i>native declaration : m68k.h:238</i> */
	public static abstract class m68k_set_bkpt_ack_callback_callback_callback extends Callback<m68k_set_bkpt_ack_callback_callback_callback > {
		public abstract void apply(int data);
	};
	/** <i>native declaration : m68k.h:246</i> */
	public static abstract class m68k_set_reset_instr_callback_callback_callback extends Callback<m68k_set_reset_instr_callback_callback_callback > {
		public abstract void apply();
	};
	/** <i>native declaration : m68k.h:255</i> */
	public static abstract class m68k_set_pc_changed_callback_callback_callback extends Callback<m68k_set_pc_changed_callback_callback_callback > {
		public abstract void apply(int new_pc);
	};
	/** <i>native declaration : m68k.h:262</i> */
	public static abstract class m68k_set_tas_instr_callback_callback_callback extends Callback<m68k_set_tas_instr_callback_callback_callback > {
		public abstract int apply();
	};
	/** <i>native declaration : m68k.h:270</i> */
	public static abstract class m68k_set_illg_instr_callback_callback_callback extends Callback<m68k_set_illg_instr_callback_callback_callback > {
		public abstract int apply(int int1);
	};
	/** <i>native declaration : m68k.h:279</i> */
	public static abstract class m68k_set_fc_callback_callback_callback extends Callback<m68k_set_fc_callback_callback_callback > {
		public abstract void apply(int new_fc);
	};
	/** <i>native declaration : m68k.h:288</i> */
	public static abstract class m68k_set_instr_hook_callback_callback_callback extends Callback<m68k_set_instr_hook_callback_callback_callback > {
		public abstract void apply(int pc);
	};
	/**
	 * Original signature : <code>void m68k_set_bus_read_callback(M68K_BUS_READ)</code><br>
	 * <i>native declaration : m68k.h:169</i>
	 */
	public static void m68k_set_bus_read_callback(Pointer<M68kcpuLibrary.M68K_BUS_READ > readFn) {
		m68k_set_bus_read_callback(Pointer.getPeer(readFn));
	}
	protected native static void m68k_set_bus_read_callback(@Ptr long readFn);
	/**
	 * Original signature : <code>void m68k_set_bus_write_callback(M68K_BUS_WRITE)</code><br>
	 * <i>native declaration : m68k.h:170</i>
	 */
	public static void m68k_set_bus_write_callback(Pointer<M68kcpuLibrary.M68K_BUS_WRITE > writeFn) {
		m68k_set_bus_write_callback(Pointer.getPeer(writeFn));
	}
	protected native static void m68k_set_bus_write_callback(@Ptr long writeFn);
	/**
	 * Read from anywhere<br>
	 * Original signature : <code>int m68k_read_memory_8(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:173</i>
	 */
	public static native int m68k_read_memory_8(int address);
	/**
	 * Original signature : <code>int m68k_read_memory_16(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:174</i>
	 */
	public static native int m68k_read_memory_16(int address);
	/**
	 * Original signature : <code>int m68k_read_memory_32(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:175</i>
	 */
	public static native int m68k_read_memory_32(int address);
	/**
	 * Read data immediately following the PC<br>
	 * Original signature : <code>int m68k_read_immediate_16(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:178</i>
	 */
	public static native int m68k_read_immediate_16(int address);
	/**
	 * Original signature : <code>int m68k_read_immediate_32(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:179</i>
	 */
	public static native int m68k_read_immediate_32(int address);
	/**
	 * Read data relative to the PC<br>
	 * Original signature : <code>int m68k_read_pcrelative_8(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:182</i>
	 */
	public static native int m68k_read_pcrelative_8(int address);
	/**
	 * Original signature : <code>int m68k_read_pcrelative_16(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:183</i>
	 */
	public static native int m68k_read_pcrelative_16(int address);
	/**
	 * Original signature : <code>int m68k_read_pcrelative_32(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:184</i>
	 */
	public static native int m68k_read_pcrelative_32(int address);
	/**
	 * Memory access for the disassembler<br>
	 * Original signature : <code>int m68k_read_disassembler_8(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:187</i>
	 */
	public static native int m68k_read_disassembler_8(int address);
	/**
	 * Original signature : <code>int m68k_read_disassembler_16(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:188</i>
	 */
	public static native int m68k_read_disassembler_16(int address);
	/**
	 * Original signature : <code>int m68k_read_disassembler_32(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:189</i>
	 */
	public static native int m68k_read_disassembler_32(int address);
	/**
	 * Write to anywhere<br>
	 * Original signature : <code>void m68k_write_memory_8(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:192</i>
	 */
	public static native void m68k_write_memory_8(int address, int value);
	/**
	 * Original signature : <code>void m68k_write_memory_16(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:193</i>
	 */
	public static native void m68k_write_memory_16(int address, int value);
	/**
	 * Original signature : <code>void m68k_write_memory_32(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:194</i>
	 */
	public static native void m68k_write_memory_32(int address, int value);
	/**
	 * Special call to simulate undocumented 68k behavior when move.l with a<br>
	 * predecrement destination mode is executed.<br>
	 * To simulate real 68k behavior, first write the high word to<br>
	 * [address+2], and then write the low word to [address].<br>
	 * Enable this functionality with M68K_SIMULATE_PD_WRITES in m68kconf.h.<br>
	 * Original signature : <code>void m68k_write_memory_32_pd(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:203</i>
	 */
	public static native void m68k_write_memory_32_pd(int address, int value);
	/**
	 * Set the callback for an interrupt acknowledge.<br>
	 * You must enable M68K_EMULATE_INT_ACK in m68kconf.h.<br>
	 * The CPU will call the callback with the interrupt level being acknowledged.<br>
	 * The host program must return either a vector from 0x02-0xff, or one of the<br>
	 * special interrupt acknowledge values specified earlier in this header.<br>
	 * If this is not implemented, the CPU will always assume an autovectored<br>
	 * interrupt, and will automatically clear the interrupt request when it<br>
	 * services the interrupt.<br>
	 * Default behavior: return M68K_INT_ACK_AUTOVECTOR.<br>
	 * Original signature : <code>void m68k_set_int_ack_callback(m68k_set_int_ack_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:229</i>
	 */
	public static void m68k_set_int_ack_callback(Pointer<M68kcpuLibrary.m68k_set_int_ack_callback_callback_callback > callback) {
		m68k_set_int_ack_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_int_ack_callback(@Ptr long callback);
	/**
	 * Set the callback for a breakpoint acknowledge (68010+).<br>
	 * You must enable M68K_EMULATE_BKPT_ACK in m68kconf.h.<br>
	 * The CPU will call the callback with whatever was in the data field of the<br>
	 * BKPT instruction for 68020+, or 0 for 68010.<br>
	 * Default behavior: do nothing.<br>
	 * Original signature : <code>void m68k_set_bkpt_ack_callback(m68k_set_bkpt_ack_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:238</i>
	 */
	public static void m68k_set_bkpt_ack_callback(Pointer<M68kcpuLibrary.m68k_set_bkpt_ack_callback_callback_callback > callback) {
		m68k_set_bkpt_ack_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_bkpt_ack_callback(@Ptr long callback);
	/**
	 * Set the callback for the RESET instruction.<br>
	 * You must enable M68K_EMULATE_RESET in m68kconf.h.<br>
	 * The CPU calls this callback every time it encounters a RESET instruction.<br>
	 * Default behavior: do nothing.<br>
	 * Original signature : <code>void m68k_set_reset_instr_callback(m68k_set_reset_instr_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:246</i>
	 */
	public static void m68k_set_reset_instr_callback(Pointer<M68kcpuLibrary.m68k_set_reset_instr_callback_callback_callback > callback) {
		m68k_set_reset_instr_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_reset_instr_callback(@Ptr long callback);
	/**
	 * Set the callback for informing of a large PC change.<br>
	 * You must enable M68K_MONITOR_PC in m68kconf.h.<br>
	 * The CPU calls this callback with the new PC value every time the PC changes<br>
	 * by a large value (currently set for changes by longwords).<br>
	 * Default behavior: do nothing.<br>
	 * Original signature : <code>void m68k_set_pc_changed_callback(m68k_set_pc_changed_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:255</i>
	 */
	public static void m68k_set_pc_changed_callback(Pointer<M68kcpuLibrary.m68k_set_pc_changed_callback_callback_callback > callback) {
		m68k_set_pc_changed_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_pc_changed_callback(@Ptr long callback);
	/**
	 * Set the callback for the TAS instruction.<br>
	 * You must enable M68K_TAS_HAS_CALLBACK in m68kconf.h.<br>
	 * The CPU calls this callback every time it encounters a TAS instruction.<br>
	 * Default behavior: return 1, allow writeback.<br>
	 * Original signature : <code>void m68k_set_tas_instr_callback(m68k_set_tas_instr_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:262</i>
	 */
	public static void m68k_set_tas_instr_callback(Pointer<M68kcpuLibrary.m68k_set_tas_instr_callback_callback_callback > callback) {
		m68k_set_tas_instr_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_tas_instr_callback(@Ptr long callback);
	/**
	 * Set the callback for illegal instructions.<br>
	 * You must enable M68K_ILLG_HAS_CALLBACK in m68kconf.h.<br>
	 * The CPU calls this callback every time it encounters an illegal instruction<br>
	 * which must return 1 if it handles the instruction normally or 0 if it's really an illegal instruction.<br>
	 * Default behavior: return 0, exception will occur.<br>
	 * Original signature : <code>void m68k_set_illg_instr_callback(m68k_set_illg_instr_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:270</i>
	 */
	public static void m68k_set_illg_instr_callback(Pointer<M68kcpuLibrary.m68k_set_illg_instr_callback_callback_callback > callback) {
		m68k_set_illg_instr_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_illg_instr_callback(@Ptr long callback);
	/**
	 * Set the callback for CPU function code changes.<br>
	 * You must enable M68K_EMULATE_FC in m68kconf.h.<br>
	 * The CPU calls this callback with the function code before every memory<br>
	 * access to set the CPU's function code according to what kind of memory<br>
	 * access it is (supervisor/user, program/data and such).<br>
	 * Default behavior: do nothing.<br>
	 * Original signature : <code>void m68k_set_fc_callback(m68k_set_fc_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:279</i>
	 */
	public static void m68k_set_fc_callback(Pointer<M68kcpuLibrary.m68k_set_fc_callback_callback_callback > callback) {
		m68k_set_fc_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_fc_callback(@Ptr long callback);
	/**
	 * Set a callback for the instruction cycle of the CPU.<br>
	 * You must enable M68K_INSTRUCTION_HOOK in m68kconf.h.<br>
	 * The CPU calls this callback just before fetching the opcode in the<br>
	 * instruction cycle.<br>
	 * Default behavior: do nothing.<br>
	 * Original signature : <code>void m68k_set_instr_hook_callback(m68k_set_instr_hook_callback_callback_callback*)</code><br>
	 * <i>native declaration : m68k.h:288</i>
	 */
	public static void m68k_set_instr_hook_callback(Pointer<M68kcpuLibrary.m68k_set_instr_hook_callback_callback_callback > callback) {
		m68k_set_instr_hook_callback(Pointer.getPeer(callback));
	}
	protected native static void m68k_set_instr_hook_callback(@Ptr long callback);
	/**
	 * Use this function to set the CPU type you want to emulate.<br>
	 * Currently supported types are: M68K_CPU_TYPE_68000, M68K_CPU_TYPE_68010,<br>
	 * M68K_CPU_TYPE_EC020, and M68K_CPU_TYPE_68020.<br>
	 * Original signature : <code>void m68k_set_cpu_type(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:300</i>
	 */
	public static native void m68k_set_cpu_type(int cpu_type);
	/**
	 * Do whatever initialisations the core requires.  Should be called<br>
	 * at least once at init time.<br>
	 * Original signature : <code>void m68k_init()</code><br>
	 * <i>native declaration : m68k.h:305</i>
	 */
	public static native void m68k_init();
	/**
	 * Pulse the RESET pin on the CPU.<br>
	 * You *MUST* reset the CPU at least once to initialize the emulation<br>
	 * Note: If you didn't call m68k_set_cpu_type() before resetting<br>
	 *       the CPU for the first time, the CPU will be set to<br>
	 *       M68K_CPU_TYPE_68000.<br>
	 * Original signature : <code>void m68k_pulse_reset()</code><br>
	 * <i>native declaration : m68k.h:313</i>
	 */
	public static native void m68k_pulse_reset();
	/**
	 * execute num_cycles worth of instructions.  returns number of cycles used<br>
	 * Original signature : <code>int m68k_execute(int)</code><br>
	 * <i>native declaration : m68k.h:316</i>
	 */
	public static native int m68k_execute(int num_cycles);
	/**
	 * These functions let you read/write/modify the number of cycles left to run<br>
	 * while m68k_execute() is running.<br>
	 * These are useful if the 68k accesses a memory-mapped port on another device<br>
	 * that requires immediate processing by another CPU.<br>
	 * Number of cycles run so far<br>
	 * Original signature : <code>int m68k_cycles_run()</code><br>
	 * <i>native declaration : m68k.h:323</i>
	 */
	public static native int m68k_cycles_run();
	/**
	 * Number of cycles left<br>
	 * Original signature : <code>int m68k_cycles_remaining()</code><br>
	 * <i>native declaration : m68k.h:324</i>
	 */
	public static native int m68k_cycles_remaining();
	/**
	 * Modify cycles left<br>
	 * Original signature : <code>void m68k_modify_timeslice(int)</code><br>
	 * <i>native declaration : m68k.h:325</i>
	 */
	public static native void m68k_modify_timeslice(int cycles);
	/**
	 * End timeslice now<br>
	 * Original signature : <code>void m68k_end_timeslice()</code><br>
	 * <i>native declaration : m68k.h:326</i>
	 */
	public static native void m68k_end_timeslice();
	/**
	 * Set the IPL0-IPL2 pins on the CPU (IRQ).<br>
	 * A transition from < 7 to 7 will cause a non-maskable interrupt (NMI).<br>
	 * Setting IRQ to 0 will clear an interrupt request.<br>
	 * Original signature : <code>void m68k_set_irq(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:332</i>
	 */
	public static native void m68k_set_irq(int int_level);
	/**
	 * Set the virtual irq lines, where the highest level<br>
	 * active line is automatically selected.  If you use this function,<br>
	 * do not use m68k_set_irq.<br>
	 * Original signature : <code>void m68k_set_virq(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:338</i>
	 */
	public static native void m68k_set_virq(int level, int active);
	/**
	 * Original signature : <code>int m68k_get_virq(unsigned int)</code><br>
	 * <i>native declaration : m68k.h:339</i>
	 */
	public static native int m68k_get_virq(int level);
	/**
	 * Halt the CPU as if you pulsed the HALT pin.<br>
	 * Original signature : <code>void m68k_pulse_halt()</code><br>
	 * <i>native declaration : m68k.h:342</i>
	 */
	public static native void m68k_pulse_halt();
	/**
	 * Trigger a bus error exception<br>
	 * Original signature : <code>void m68k_pulse_bus_error()</code><br>
	 * <i>native declaration : m68k.h:346</i>
	 */
	public static native void m68k_pulse_bus_error();
	/**
	 * Get the size of the cpu context in bytes<br>
	 * Original signature : <code>int m68k_context_size()</code><br>
	 * <i>native declaration : m68k.h:352</i>
	 */
	public static native int m68k_context_size();
	/**
	 * Get a cpu context<br>
	 * Original signature : <code>int m68k_get_context(void*)</code><br>
	 * <i>native declaration : m68k.h:355</i>
	 */
	public static int m68k_get_context(Pointer<? > dst) {
		return m68k_get_context(Pointer.getPeer(dst));
	}
	protected native static int m68k_get_context(@Ptr long dst);
	/**
	 * set the current cpu context<br>
	 * Original signature : <code>void m68k_set_context(void*)</code><br>
	 * <i>native declaration : m68k.h:358</i>
	 */
	public static void m68k_set_context(Pointer<? > dst) {
		m68k_set_context(Pointer.getPeer(dst));
	}
	protected native static void m68k_set_context(@Ptr long dst);
	/**
	 * Register the CPU state information<br>
	 * Original signature : <code>void m68k_state_register(const char*, int)</code><br>
	 * <i>native declaration : m68k.h:361</i>
	 */
	public static void m68k_state_register(Pointer<Byte > type, int index) {
		m68k_state_register(Pointer.getPeer(type), index);
	}
	protected native static void m68k_state_register(@Ptr long type, int index);
	/**
	 * Peek at the internals of a CPU context.  This can either be a context<br>
	 * retrieved using m68k_get_context() or the currently running context.<br>
	 * If context is NULL, the currently running CPU context will be used.<br>
	 * Original signature : <code>int m68k_get_reg(void*, m68k_register_t)</code><br>
	 * <i>native declaration : m68k.h:368</i>
	 */
	public static int m68k_get_reg(Pointer<? > context, IntValuedEnum<M68kcpuLibrary.m68k_register_t > reg) {
		return m68k_get_reg(Pointer.getPeer(context), (int)reg.value());
	}
	protected native static int m68k_get_reg(@Ptr long context, int reg);
	/**
	 * Poke values into the internals of the currently running CPU context<br>
	 * Original signature : <code>void m68k_set_reg(m68k_register_t, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:371</i>
	 */
	public static void m68k_set_reg(IntValuedEnum<M68kcpuLibrary.m68k_register_t > reg, int value) {
		m68k_set_reg((int)reg.value(), value);
	}
	protected native static void m68k_set_reg(int reg, int value);
	/**
	 * Check if an instruction is valid for the specified CPU type<br>
	 * Original signature : <code>int m68k_is_valid_instruction(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:374</i>
	 */
	public static native int m68k_is_valid_instruction(int instruction, int cpu_type);
	/**
	 * Disassemble 1 instruction using the epecified CPU type at pc.  Stores<br>
	 * disassembly in str_buff and returns the size of the instruction in bytes.<br>
	 * Original signature : <code>int m68k_disassemble(char*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:379</i>
	 */
	public static int m68k_disassemble(Pointer<Byte > str_buff, int pc, int cpu_type) {
		return m68k_disassemble(Pointer.getPeer(str_buff), pc, cpu_type);
	}
	protected native static int m68k_disassemble(@Ptr long str_buff, int pc, int cpu_type);
	/**
	 * Same as above but accepts raw opcode data directly rather than fetching<br>
	 * via the read/write interfaces.<br>
	 * Original signature : <code>int m68k_disassemble_raw(char*, unsigned int, const unsigned char*, const unsigned char*, unsigned int)</code><br>
	 * <i>native declaration : m68k.h:384</i>
	 */
	public static int m68k_disassemble_raw(Pointer<Byte > str_buff, int pc, Pointer<Byte > opdata, Pointer<Byte > argdata, int cpu_type) {
		return m68k_disassemble_raw(Pointer.getPeer(str_buff), pc, Pointer.getPeer(opdata), Pointer.getPeer(argdata), cpu_type);
	}
	protected native static int m68k_disassemble_raw(@Ptr long str_buff, int pc, @Ptr long opdata, @Ptr long argdata, int cpu_type);
	/**
	 * quick disassembly (used for logging)<br>
	 * Original signature : <code>char* m68ki_disassemble_quick(unsigned int, unsigned int)</code><br>
	 * <i>native declaration : m68kcpu.h:991</i>
	 */
	public static Pointer<Byte > m68ki_disassemble_quick(int pc, int cpu_type) {
		return (Pointer)Pointer.pointerToAddress(m68ki_disassemble_quick$2(pc, cpu_type), Byte.class);
	}
	@Ptr 
	@Name("m68ki_disassemble_quick") 
	protected native static long m68ki_disassemble_quick$2(int pc, int cpu_type);
	/**
	 * Original signature : <code>void dump_info(char*)</code><br>
	 * <i>native declaration : m68kcpu.h:992</i>
	 */
	public static void dump_info(Pointer<Byte > charPtr1) {
		dump_info(Pointer.getPeer(charPtr1));
	}
	protected native static void dump_info(@Ptr long charPtr1);
	/**
	 * ---------------------------- Read Immediate ----------------------------<br>
	 * Original signature : <code>uint pmmu_translate_addr(uint)</code><br>
	 * <i>native declaration : m68kcpu.h:1001</i>
	 */
	public static native int pmmu_translate_addr(int addr_in);
	/** C type : extern m68ki_cpu_core */
	public m68ki_cpu_core m68ki_cpu() {
		try {
			return (m68ki_cpu_core)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_cpu").as(m68ki_cpu_core.class).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern m68ki_cpu_core */
	public M68kcpuLibrary m68ki_cpu(m68ki_cpu_core m68ki_cpu) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_cpu").as(m68ki_cpu_core.class).set(m68ki_cpu);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern sint */
	public int m68ki_remaining_cycles() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_remaining_cycles").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern sint */
	public M68kcpuLibrary m68ki_remaining_cycles(int m68ki_remaining_cycles) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_remaining_cycles").setInt(m68ki_remaining_cycles);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public int m68ki_tracing() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_tracing").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public M68kcpuLibrary m68ki_tracing(int m68ki_tracing) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_tracing").setInt(m68ki_tracing);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint8[] */
	public Pointer<Byte > m68ki_shift_8_table() {
		try {
			return (Pointer<Byte >)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_8_table").as(DefaultParameterizedType.paramType(Pointer.class, Byte.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint8[] */
	public M68kcpuLibrary m68ki_shift_8_table(Pointer<Byte > m68ki_shift_8_table) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_8_table").as(DefaultParameterizedType.paramType(Pointer.class, Byte.class)).set(m68ki_shift_8_table);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint16[] */
	public Pointer<Short > m68ki_shift_16_table() {
		try {
			return (Pointer<Short >)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_16_table").as(DefaultParameterizedType.paramType(Pointer.class, Short.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint16[] */
	public M68kcpuLibrary m68ki_shift_16_table(Pointer<Short > m68ki_shift_16_table) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_16_table").as(DefaultParameterizedType.paramType(Pointer.class, Short.class)).set(m68ki_shift_16_table);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint[] */
	public Pointer<Integer > m68ki_shift_32_table() {
		try {
			return (Pointer<Integer >)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_32_table").as(DefaultParameterizedType.paramType(Pointer.class, Integer.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint[] */
	public M68kcpuLibrary m68ki_shift_32_table(Pointer<Integer > m68ki_shift_32_table) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_shift_32_table").as(DefaultParameterizedType.paramType(Pointer.class, Integer.class)).set(m68ki_shift_32_table);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint8[][256] */
	@Array({256}) 
	public Pointer<Byte > m68ki_exception_cycle_table() {
		try {
			return (Pointer<Byte >)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_exception_cycle_table").as(DefaultParameterizedType.paramType(Pointer.class, Byte.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public int m68ki_address_space() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_address_space").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public M68kcpuLibrary m68ki_address_space(int m68ki_address_space) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_address_space").setInt(m68ki_address_space);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint8[] */
	public Pointer<Byte > m68ki_ea_idx_cycle_table() {
		try {
			return (Pointer<Byte >)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_ea_idx_cycle_table").as(DefaultParameterizedType.paramType(Pointer.class, Byte.class)).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern const uint8[] */
	public M68kcpuLibrary m68ki_ea_idx_cycle_table(Pointer<Byte > m68ki_ea_idx_cycle_table) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_ea_idx_cycle_table").as(DefaultParameterizedType.paramType(Pointer.class, Byte.class)).set(m68ki_ea_idx_cycle_table);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public int m68ki_aerr_address() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_address").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public M68kcpuLibrary m68ki_aerr_address(int m68ki_aerr_address) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_address").setInt(m68ki_aerr_address);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public int m68ki_aerr_write_mode() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_write_mode").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public M68kcpuLibrary m68ki_aerr_write_mode(int m68ki_aerr_write_mode) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_write_mode").setInt(m68ki_aerr_write_mode);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public int m68ki_aerr_fc() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_fc").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern uint */
	public M68kcpuLibrary m68ki_aerr_fc(int m68ki_aerr_fc) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_aerr_fc").setInt(m68ki_aerr_fc);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	/** C type : extern jmp_buf */
	@Array({1}) 
	public M68kcpuLibrary.jmp_buf m68ki_bus_error_jmp_buf() {
		try {
			return (M68kcpuLibrary.jmp_buf)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("m68ki_bus_error_jmp_buf").as(M68kcpuLibrary.jmp_buf.class).get();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	public int cpu_log_enabled() {
		try {
			return (int)BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("cpu_log_enabled").getInt();
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	public M68kcpuLibrary cpu_log_enabled(int cpu_log_enabled) {
		try {
			{
				BridJ.getNativeLibrary("m68kcpu").getSymbolPointer("cpu_log_enabled").setInt(cpu_log_enabled);
				return this;
			}
		}catch (Throwable $ex$) {
			throw new RuntimeException($ex$);
		}
	}
	public static class jmp_buf extends TypedPointer {
		public jmp_buf(long address) {
			super(address);
		}
		public jmp_buf(Pointer address) {
			super(address);
		}
	};
}
